using System;
using System.Text;

namespace Corecalc {
	/// <summary>
	/// An ArrayValue holds an array (rectangle) of Values resulting from evaluation.
	/// </summary>
	public abstract class ArrayValue : Value {
		public new static readonly Type type = typeof(ArrayValue);

		public abstract int Cols { get; }

		public abstract int Rows { get; }

		// Get cell value from array value
		public virtual Value this[CellAddr ca] {
			get { return this[ca.col, ca.row]; }
		}

		public abstract Value this[int col, int row] { get; }

		public override Object ToObject() {
			return (Object)this;
		}

		// Used to implement INDEX(area,row,col), truncated 1-based indexing
		public Value Index(double deltaRow, double deltaCol) {
			int col = (int)deltaCol - 1, row = (int)deltaRow - 1;
			if (0 <= col && col < Cols && 0 <= row && row < Rows)
				return this[col, row] ?? NumberValue.ZERO;
			else
				return ErrorValue.refError;
		}

		public abstract Value View(CellAddr ulCa, CellAddr lrCa);

		public abstract Value Slice(CellAddr ulCa, CellAddr lrCa);

		// Used to implement SLICE(arr, r1, c1, r2, c2)
		// A slice may be empty (when r1=r2+1 or c1=c2+1) whereas a View usually is not
		public Value Slice(double r1, double c1, double r2, double c2) {
			int ir1 = (int)r1 - 1, ic1 = (int)c1 - 1, ir2 = (int)r2 - 1, ic2 = (int)c2 - 1;
			if (0 <= ir1 && ir1 <= ir2 + 1 && ir2 < Rows && 0 <= ic1 && ic1 <= ic2 + 1 && ic2 < Cols)
				return Slice(new CellAddr(ic1, ir1), new CellAddr(ic2, ir2));
			else
				return ErrorValue.refError;
		}

		// These are called from interpreted EXTERN and from generated bytecode
		public static double[] ToDoubleArray1D(Value v) {
			ArrayValue arr = v as ArrayValue;
			if (arr != null && arr.Rows == 1) {
				double[] res = new double[arr.Cols];
				for (int c = 0; c < arr.Cols; c++)
					if (arr[c, 0] is NumberValue)
						res[c] = (arr[c, 0] as NumberValue).value;
					else
						return null;
				return res;
			} else
				return null;
		}

		public static double[,] ToDoubleArray2D(Value v) {
			ArrayValue arr = v as ArrayValue;
			if (arr != null) 
				return arr.ToDoubleArray2DFast();
			else
				return null;
		}

		public static String[] ToStringArray1D(Value v) {
			ArrayValue arr = v as ArrayValue;
			if (arr != null && arr.Rows == 1) {
				String[] res = new String[arr.Cols];
				for (int c = 0; c < arr.Cols; c++)
					if (arr[c, 0] is TextValue)
						res[c] = (arr[c, 0] as TextValue).value;
					else
						return null;
				return res;
			} else
				return null;
		}

		public static Value FromStringArray1D(Object o) {
			String[] ss = o as String[];
			if (ss != null) {
				Value[,] vs = new Value[ss.Length, 1];
				for (int c = 0; c < ss.Length; c++)
					vs[c, 0] = TextValue.FromString(ss[c]);
				return new ArrayExplicit(vs);
			} else
				return ErrorValue.argTypeError;
		}

		public static Value FromDoubleArray1D(Object o) {
			double[] xs = o as double[];
			if (xs != null) {
				Value[,] vs = new Value[xs.Length, 1];
				for (int c = 0; c < xs.Length; c++)
					vs[c, 0] = NumberValue.Make(xs[c]);
				return new ArrayExplicit(vs);
			} else
				return ErrorValue.argTypeError;
		}

		public static Value FromDoubleArray2D(Object o) {
			double[,] xs = o as double[,];
			if (xs != null)
				return new ArrayDouble(xs);
			else
				return ErrorValue.argTypeError;
		}
      
		// Override in ArrayDouble for efficiency
		public virtual double[,] ToDoubleArray2DFast() {
			double[,] res = new double[Rows, Cols];
			for (int c = 0; c < Cols; c++)
				for (int r = 0; r < Rows; r++)
					if (this[c, r] is NumberValue)
						res[r, c] = (this[c, r] as NumberValue).value;
					else
						return null;
			return res;
		}

		public void Apply(Action<double> act) {
			for (int c = 0; c < Cols; c++) {
				for (int r = 0; r < Rows; r++) {
					Value v = this[c, r];
					if (v != null) // Only non-blank cells contribute
						if (v is ArrayValue)
							(v as ArrayValue).Apply(act);
						else
							act(Value.ToDoubleOrNan(v));
				}
			}
		}

		public override void Apply(Action<Value> act) {
			for (int c = 0; c < Cols; c++) {
				for (int r = 0; r < Rows; r++) {
					Value v = this[c, r];
					if (v != null) // Only non-blank cells contribute
						if (v is ArrayValue)
							(v as ArrayValue).Apply(act);
						else
							act(v);
				}
			}
		}

		public static bool EqualElements(ArrayValue arr1, ArrayValue arr2) {
			if (arr1 == arr2)
				return true;
			if (arr1 == null || arr2 == null)
				return false;
			if (arr1.Rows != arr2.Rows || arr1.Cols != arr2.Cols)
				return false;
			for (int c = 0; c < arr1.Cols; c++)
				for (int r = 0; r < arr1.Rows; r++) {
					Value v1 = arr1[c, r], v2 = arr2[c, r];
					if (v1 != v2)
						if (v1 == null || v2 == null)
							return false;
						else if (!(v1.Equals(v2)))
							return false;
				}
			return true;
		}

		public override int GetHashCode() {
			int result = Rows * 37 + Cols;
			for (int i = 0; i < Rows && i < Cols; i++)
				result = result * 37 + this[i, i].GetHashCode();
			return result;
		}

		public override String ToString() {
			StringBuilder sb = new StringBuilder();
			for (int r = 0; r < Rows; r++) {
				for (int c = 0; c < Cols; c++) {
					Value v = this[c, r];
					sb.Append(v == null ? "[none]" : v.ToString());
					if (c < Cols - 1)
						sb.Append("\t");
				}
				if (r < Rows - 1)
					sb.Append("\n");
			}
			return sb.ToString();
		}
	}
}