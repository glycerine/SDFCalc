// Funcalc, spreadsheet with functions
// ----------------------------------------------------------------------
// Copyright (c) 2006-2014 Peter Sestoft

// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

//  * The above copyright notice and this permission notice shall be
//    included in all copies or substantial portions of the Software.

//  * The software is provided "as is", without warranty of any kind,
//    express or implied, including but not limited to the warranties of
//    merchantability, fitness for a particular purpose and
//    noninfringement.  In no event shall the authors or copyright
//    holders be liable for any claim, damages or other liability,
//    whether in an action of contract, tort or otherwise, arising from,
//    out of or in connection with the software or the use or other
//    dealings in the software.
// ----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Reflection.Emit;
using System.Text;

namespace Corecalc.Funcalc {
	/// <summary>
	/// A CGExpr represents an expression as used in sheet-defined functions,
	/// suitable for code generation and partial evaluation.
	/// </summary>
	public abstract class CGExpr : CodeGenerate, IDepend {
		/// <summary>
		///  The entry point for compilation, called from ProgramLines.  
		///  The generated code must leave a Value on the stack top.
		/// </summary>
		public abstract void Compile();

		/// <summary>
		/// Compile expression that is expected to evaluate to a number, leaving 
		/// a float64 on the stack top and avoiding wrapping where possible.  
		/// If result is an error, produce a NaN whose 32 least significant bits
		/// give that error's int index into the ErrorValue.errorTable arraylist.
		/// </summary>
		public abstract void CompileToDoubleOrNan();

		// General version in terms of CompileToDoubleOrNan.  
		// Should be overridden in CGNumberConst, CGTextConst, CGError, CGComposite ...
		/// <summary>
		/// Compile expression that is expected to evaluate to a proper (finite 
		/// and non-NaN) number; generate code to test whether it is actually a 
		/// proper number and then execute the code generated by ifProper, or 
		/// else execute the code generated by ifOther.
		/// </summary>
		/// <param name="ifProper">Generates code for the case where the expression 
		/// evaluates to a proper number; the generated code expects to find the value as
		/// an unwrapped proper float64 on the stack top.</param>
		/// <param name="ifOther"></param>
		public virtual void CompileToDoubleProper(Gen ifProper, Gen ifOther) {
			CompileToDoubleOrNan();
			ilg.Emit(OpCodes.Stloc, testDouble);
			ilg.Emit(OpCodes.Ldloc, testDouble);
			ilg.Emit(OpCodes.Call, isInfinityMethod);
			ilg.Emit(OpCodes.Brtrue, ifOther.GetLabel(ilg));
			ilg.Emit(OpCodes.Ldloc, testDouble);
			ilg.Emit(OpCodes.Call, isNaNMethod);
			ilg.Emit(OpCodes.Brtrue, ifOther.GetLabel(ilg));
			ilg.Emit(OpCodes.Ldloc, testDouble);
			ifProper.Generate(ilg);
			if (!ifOther.Generated) {
				Label endLabel = ilg.DefineLabel();
				ilg.Emit(OpCodes.Br, endLabel);
				ifOther.Generate(ilg);
				ilg.MarkLabel(endLabel);
			}
		}

		/// <summary>
		/// Compiles an expression as a condition, that can be true (if non-zero) or 
		/// false (if zero) or other (if +/-infinity or NaN).  If possible, avoids 
		/// computing and pushing a value and then testing it, instead performing 
		/// comparisons directly on arguments, or even statically.  This implementation 
		/// is a general version in terms of CompileToDoubleProper.  Should be overridden 
		/// in CGNumberConst, CGTextConst, CGError, CGIf, CGComparison, ...
		/// </summary>
		/// <param name="ifTrue">Generates code for the true branch</param>
		/// <param name="ifFalse">Generates code for the false branch</param>
		/// <param name="ifOther">Generates code for the other (neither true nor 
		/// false) branch</param>
		public virtual void CompileCondition(Gen ifTrue, Gen ifFalse, Gen ifOther) {
			CompileToDoubleProper(
								  new Gen(delegate {
											  ilg.Emit(OpCodes.Ldc_R8, 0.0);
											  ilg.Emit(OpCodes.Beq, ifFalse.GetLabel(ilg));
											  ifTrue.Generate(ilg);
											  if (!ifFalse.Generated) {
												  Label endLabel = ilg.DefineLabel();
												  ilg.Emit(OpCodes.Br, endLabel);
												  ifFalse.Generate(ilg);
												  ilg.MarkLabel(endLabel);
											  }
										  }),
								  ifOther);
		}

		/// <summary>
		/// Specialize the expression with respect to the values/residual expressions in pEnv.
		/// </summary>
		/// <param name="pEnv">Maps cell addresses to already-specialized expressions</param>
		/// <returns>The specialized expression</returns>
		public abstract CGExpr PEval(PEnv pEnv, bool hasDynamicControl);

		/// <summary>
		/// Update the evaluation conditions (in the evalConds dictionary) for every cell
		/// referenced from this expression, assuming that this expression itself 
		/// has evaluation condition evalCond.
		/// </summary>
		/// <param name="evalCond"></param>
		/// <param name="evalConds"></param>
		public abstract void EvalCond(PathCond evalCond,
									  IDictionary<FullCellAddr, PathCond> evalConds,
									  List<CGCachedExpr> caches);

		/// <summary>
		/// Called on a sheet-defined function's output 
		/// cell expression to record that that expression and some of its
		/// subexpressions are in tail position.  Only overridden in CGIf, 
		/// CGChoose and CGSdfCall (but not CGApply).
		/// </summary>
		public virtual void NoteTailPosition() {}

		/// <summary>
		/// Returns true if the expression's evaluation could 
		/// be recursive, have side effects, or take a long time.
		/// </summary>
		/// <param name="bound">The bound on non-serious expression size</param>
		public virtual bool IsSerious(ref int bound) {
			return 0 > bound--;
		}

		public abstract void DependsOn(FullCellAddr here, Action<FullCellAddr> dependsOn);

		/// <summary>
		/// Update the numberUses bag with the number of number-uses of each full cell
		/// address in this expression.
		/// </summary>
		/// <param name="typ">The expected type of this expression</param>
		/// <param name="numberUses">A hashbag noting for each full cell address
		/// the number of times it is used as a NumberValue.</param>
		public abstract void CountUses(Typ typ, HashBag<FullCellAddr> numberUses);

		public abstract Typ Type();

		public bool Is(double d) { return this is CGNumberConst && (this as CGNumberConst).number.value == d; }
	}

	// TODO: Comparisons should also be made to work for strings etc.  Static type
	// information should be exploited when available, and when not, 
	// a general comparer should be generated.  For doubles, we should
	// check that we're consistent with respect to unordered comparison.
}