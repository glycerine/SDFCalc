// Funcalc, spreadsheet with functions
// ----------------------------------------------------------------------
// Copyright (c) 2006-2014 Peter Sestoft and others

// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

//  * The above copyright notice and this permission notice shall be
//    included in all copies or substantial portions of the Software.

//  * The software is provided "as is", without warranty of any kind,
//    express or implied, including but not limited to the warranties of
//    merchantability, fitness for a particular purpose and
//    noninfringement.  In no event shall the authors or copyright
//    holders be liable for any claim, damages or other liability,
//    whether in an action of contract, tort or otherwise, arising from,
//    out of or in connection with the software or the use or other
//    dealings in the software.
// ----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace Corecalc.Funcalc {
  /// <summary>
  /// A Typ is the type of a spreadsheet value, used for return type 
  /// and argument types of built-in functions.
  /// </summary>
  public enum Typ { Error, Number, Text, Array, Function, Value };

  /// <summary>
  /// Class CodeGenerate holds all global methods and state for code 
  /// generation from sheet-defined functions.
  /// </summary>
  public abstract class CodeGenerate {
    /// <summary>
    /// When true, the evaluation conditions take into account that AND
    /// and OR have short-circuit evaluation.  This gives more accurate
    /// but more complex evaluation conditions, which may be undesirable.
    /// </summary>
    public readonly bool SHORTCIRCUIT_EVALCONDS = false;

    /// <summary>
    /// The IL generator for a single function body, used by the
    /// CGExpr compile functions.  Set by the Initialize method, 
    /// which must be called before any compilation methods.
    /// </summary>
    public static ILGenerator ilg;

    /// <summary>
    /// These temporaries are used in code that tests whether a Value 
    /// is a NumberValue, whether a double is proper, and so on
    /// </summary>
    protected static LocalBuilder testValue;
    protected static LocalBuilder testDouble;
    protected static LocalBuilder tmpFullCellAddr;

    protected static readonly MethodInfo isInfinityMethod
      = typeof(double).GetMethod("IsInfinity", new Type[] { typeof(double) });
    protected static readonly MethodInfo isNaNMethod
      = typeof(double).GetMethod("IsNaN", new Type[] { typeof(double) });

    /// <summary>
    /// Maps cell address to a variable that holds the cell's value 
    /// as a double, if any such variable exists
    /// </summary>
    private static Dictionary<FullCellAddr, Variable> numberVariables;

    /// <summary>
    /// Initializes the CodeGenerator infrastructure, binds the ILGenerator, 
    /// creates temporaries; resets evaluation condition caches.
    /// Ready to compile a new SDF.
    /// </summary>
    /// <param name="ilg">The ILGenerator used by all compile methods</param>
    public static void Initialize(ILGenerator ilg) {
      CodeGenerate.ilg = ilg;
      numberVariables = new Dictionary<FullCellAddr, Variable>();
      testDouble = ilg.DeclareLocal(typeof(double));
      testValue = ilg.DeclareLocal(Value.type);
      tmpFullCellAddr = ilg.DeclareLocal(FullCellAddr.type);
    }

    protected static void LoadErrorValue(ErrorValue error) {
      ilg.Emit(OpCodes.Ldc_I4, error.index);
      ilg.Emit(OpCodes.Call, ErrorValue.fromIndexMethod);
    }

    protected static void LoadErrorNan(ErrorValue error) {
      ilg.Emit(OpCodes.Ldc_R8, error.ErrorNan);
    }

    protected static Gen GenLoadErrorValue(ErrorValue error) {
      return new Gen(delegate { LoadErrorValue(error); });
    }

    protected static Gen GenLoadErrorNan(ErrorValue error) {
      return new Gen(delegate { LoadErrorNan(error); });
    }

    // The code generated by this method expects that the local var testDouble 
    // contains a NaN or Inf representing the error.
    protected static Gen GenLoadTestDoubleErrorValue() {
      return new Gen(delegate {
        ilg.Emit(OpCodes.Ldloc, testDouble);
        WrapDoubleToNumberValue();
      });
    }

    protected static void SetArgCountErrorNan() {
      ilg.Emit(OpCodes.Ldc_R8, ErrorValue.argCountError.ErrorNan);
      ilg.Emit(OpCodes.Stloc, testDouble);
    }

    public static Dictionary<FullCellAddr, Variable> NumberVariables {
      get { return numberVariables; }
    }

    /// <summary>
    /// Generate code to check the type of the stack top value, and leave it 
    /// there if it is of the expected type t followed by success code; else
    /// jump to failure code.
    /// </summary>
    /// <param name="t">The expected type of the stack top value.</param>
    /// <param name="ifType">Generate success code -- the value is of the expected type.</param>
    /// <param name="ifOther">Generate failure code -- the value is not of the expected type.</param>
    protected void CheckType(Type t, Gen ifType, Gen ifOther) {
      ilg.Emit(OpCodes.Stloc, testValue);
      ilg.Emit(OpCodes.Ldloc, testValue);
      ilg.Emit(OpCodes.Isinst, t);
      ilg.Emit(OpCodes.Brfalse, ifOther.GetLabel(ilg));
      ilg.Emit(OpCodes.Ldloc, testValue);
      ifType.Generate(ilg);
      if (!ifOther.Generated) {
        Label endLabel = ilg.DefineLabel();
        ilg.Emit(OpCodes.Br, endLabel);
        ifOther.Generate(ilg);
        ilg.MarkLabel(endLabel);
      }
    }

    protected void UnwrapToString(Gen ifString, Gen ifError) {
      CheckType(TextValue.type,
          new Gen(delegate {
            ilg.Emit(OpCodes.Ldfld, TextValue.valueField);
            ifString.Generate(ilg);
          }),
        ifError);
    }

    // Convert NumberValue to the enclosed float64, convert ErrorValue to its
    // NaN representation, and convert anything else to the NaN for ArgTypeError
    protected void UnwrapToDoubleOrNan() {
      ilg.Emit(OpCodes.Call, Value.toDoubleOrNanMethod);
    }

    public static void WrapDoubleToNumberValue() {
      ilg.Emit(OpCodes.Call, NumberValue.makeMethod);
    }

    /// <summary>
    /// Compute least upper bound of two types in the Typ type lattice.
    /// </summary>
    /// <returns>The least upper bound of the two argument types.</returns>
    protected Typ Lub(Typ typ1, Typ typ2) {
      if (typ1 == typ2) { return typ1; } else {
        switch (typ1) {
          case Typ.Error:
            return typ2;
          case Typ.Number:
          case Typ.Text:
          case Typ.Array:
          case Typ.Function:
            return typ2 == Typ.Error ? typ1 : Typ.Value;
          case Typ.Value:
            return Typ.Value;
          default:
            throw new ImpossibleException("Lub(Typ, Typ)");
        }
      }
    }

    /// <summary>
    /// Generate code to allocate an array vs of type Value[] and with length arity,
    /// then evaluate each argument expression es[i] to a Value and storing it 
    /// in vs[i].  Leaves vs on the stack top.
    /// </summary>
    /// <param name="arity">The total number of arguments.</param>
    /// <param name="offset">The number of given argument expressions to ignore.</param>
    /// <param name="es">The given (partial) argument expressions.</param>
    internal static void CompileToValueArray(int arity, int offset, CGExpr[] es) {
      CreateValueArray(arity);
      CompileExpressionsAndStore(offset, es);
    }

    /// <summary>
    /// Generates code to evaluate each expression es[sourceOffset,...] and  
    /// store it into array vs[0,...] on the stack top.
    /// Assumes an array vs of type Value[] is on the stack, and leaves array vs there.
    /// </summary>
    /// <param name="offset">The number of given argument expressions to ignore</param>
    /// <param name="es">The given (partial) argument expressions</param>
    internal static void CompileExpressionsAndStore(int sourceOffset, CGExpr[] es) {
      for (int i = sourceOffset; i < es.Length; i++) {
        ilg.Emit(OpCodes.Dup);
        ilg.Emit(OpCodes.Ldc_I4, i - sourceOffset);
        es[i].Compile();
        ilg.Emit(OpCodes.Stelem_Ref);
      }
    }

    /// <summary>
    /// Generates code to allocate a Value array, as in new Value[arity].
    /// </summary>
    /// <param name="arity">The size of the new array.</param>
    internal static void CreateValueArray(int arity) {
      ilg.Emit(OpCodes.Ldc_I4, arity);
      ilg.Emit(OpCodes.Newarr, Value.type);
    }
  }
}
